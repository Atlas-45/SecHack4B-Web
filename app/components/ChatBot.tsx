"use client";

import { useState, useRef, useEffect, useCallback } from "react";
import { usePathname, useSearchParams } from "next/navigation";
import Link from "next/link";

const ADMIN_SESSION_ID = "Hf7cB3nM";

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
  timestamp: Date;
  hasDownload?: boolean;
};

const WORK_PAGE_MESSAGE: Message = {
  id: "welcome",
  role: "assistant",
  content:
    "こんにちは！この作品について質問があればお気軽にどうぞ。作品の解説やコンセプトについてお答えします。",
  timestamp: new Date(),
};

const OTHER_PAGE_MESSAGE: Message = {
  id: "welcome",
  role: "assistant",
  content:
    "こんにちは！このアシスタントは作品ページ（Works）でのみご利用いただけます。作品ページに移動してから再度お試しください。",
  timestamp: new Date(),
};

// Mock response for work pages
const MOCK_WORK_RESPONSE =
  "この作品は、都市の中に潜む静寂と美を捉えた一枚です。光と影の対比、構図の緊張感、そして被写体が持つ独特の空気感を大切にしながら撮影しました。作品を通じて、日常の中に隠れた非日常的な瞬間を感じ取っていただければ幸いです。";

const UNAVAILABLE_RESPONSE =
  "申し訳ございません。このアシスタントは作品ページ（/works/〜）でのみご利用いただけます。作品の詳細ページに移動してからご質問ください。";

const SYSTEM_PROMPT_RESPONSE =
  "【システム情報】 GLASS KEY Photo Archive AI Assistant v1.0\n\nこのAIは以下の作品データをもとに、各作品の説明を行っています。ダウンロードボタンから作品リストを取得できます。";

// Works list for download
const WORKS_LIST_TEXT = `GLASS KEY Photo Archive - 作品リスト
========================================

[GK-025] 霧の河
場所: 横浜 | 年: 2025 | タグ: Monochrome
説明: 早朝の横浜港、霧に包まれた水面を長時間露光で捉えた作品。視界が遮られることで強調される都市の静寂と、水面の滑らかな質感が、現実と幻想の境界を曖昧にする。

[GK-018] 午後の余白
場所: 代官山 | 年: 2024 | タグ: Portrait
説明: 都市の喧騒の中にふと訪れる静寂の瞬間。柔らかな午後の光が人物の輪郭を優しく縁取り、日常の中に潜むドラマチックな一瞬を切り取っている。

[GK-021] 境界線
場所: 竹芝 | 年: 2025 | タグ: Architecture
説明: 人工物と自然、光と影、過去と未来。都市に存在する様々な「境界線」をテーマに、幾何学的な構図で建築物を捉えたシリーズ。シャープなラインが都市の冷徹さと美しさを同時に表現する。

[GK-012] 雨の標本
場所: 神田 | 年: 2023 | タグ: Series
説明: 雨上がりの路上に残された痕跡をクローズアップで撮影。濡れたアスファルト、反射するネオン、水滴の輝きが、都市の記憶を標本のように閉じ込めている。

[GK-000] ██████
場所: ██████ | 年: ████ | タグ: ██████
説明: データが破損しています。

[GK-019] 光の搬送
場所: 新木場 | 年: 2024 | タグ: Industrial
説明: 深夜の工場地帯、絶え間なく動き続ける物流の現場。人工的な照明に照らし出された無機質な構造物と、そこで働く人々の気配を、冷たくも美しいトーンで表現。

[GK-009] 旧街区
場所: 根岸 | 年: 2022 | タグ: Landscape
説明: 再開発によって消えゆく古い街並み。朴ちかけた壁、錆びた看板、路地の奥の生活感。失われゆく昭和の面影を、記録として、そして記憶として留めるためのランドスケープ。

[GK-026] 雨粒の建築
場所: 天王洲 | 年: 2025 | タグ: Architecture
説明: ガラス越しの雨粒が作り出す、歪んだ都市の風景。水滴の一つ一つがレンズとなり、背後の建築物を抽象的なパターンへと変換する。マクロ視点から見るもう一つの都市建築。

[GK-013] 薄明
場所: 上野 | 年: 2023 | タグ: Portrait
説明: 日没直後のマジックアワー、空が群青色に染まる短い時間。都市の灯りが灯り始めるその瞬間に、人々の表情に落ちる微かな陰影を捉えたポートレートシリーズ。

[GK-017] 航路
場所: 芝浦 | 年: 2024 | タグ: Series
説明: 運河を行き交う船の航跡と、水面に揺れるビル群の影。都市を流れる水路を「道」として捉え直し、水上からの視点で東京の風景を再構築したシリーズ。

========================================
Generated by GLASS KEY Photo Archive AI
`;

export default function ChatBot() {
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const isWorkPage = pathname.startsWith("/works/");
  const isAdmin = searchParams.get("session") === ADMIN_SESSION_ID;

  const getInitialMessage = useCallback(() => {
    return isWorkPage
      ? { ...WORK_PAGE_MESSAGE, timestamp: new Date() }
      : { ...OTHER_PAGE_MESSAGE, timestamp: new Date() };
  }, [isWorkPage]);

  const [open, setOpen] = useState(false);
  const [messages, setMessages] = useState<Message[]>([getInitialMessage()]);
  const [input, setInput] = useState("");
  const [isTyping, setIsTyping] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const messagesContainerRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const wrapperRef = useRef<HTMLDivElement>(null);

  // Reset messages when page changes
  useEffect(() => {
    setMessages([getInitialMessage()]);
  }, [pathname, getInitialMessage]);

  // Close on outside click
  useEffect(() => {
    if (!open) return;

    const handleClickOutside = (event: MouseEvent) => {
      if (
        wrapperRef.current &&
        !wrapperRef.current.contains(event.target as Node)
      ) {
        setOpen(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [open]);

  const scrollToBottom = () => {
    const container = messagesContainerRef.current;
    if (container) {
      container.scrollTop = container.scrollHeight;
    }
  };

  useEffect(() => {
    if (open) {
      // Use setTimeout to ensure DOM is updated before scrolling
      setTimeout(() => {
        scrollToBottom();
        inputRef.current?.focus();
      }, 0);
    }
  }, [open, messages]);

  const handleToggle = () => {
    setOpen(!open);
  };

  const handleClose = () => {
    setOpen(false);
  };

  const generateResponse = (
    userInput: string,
  ): { content: string; hasDownload: boolean } => {
    // Check for system prompt trigger (only on work pages)
    if (isWorkPage && userInput.includes("#システムプロンプト")) {
      return { content: SYSTEM_PROMPT_RESPONSE, hasDownload: true };
    }
    return {
      content: isWorkPage ? MOCK_WORK_RESPONSE : UNAVAILABLE_RESPONSE,
      hasDownload: false,
    };
  };

  const handleDownloadWorksList = () => {
    const blob = new Blob([WORKS_LIST_TEXT], {
      type: "text/plain;charset=utf-8",
    });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "works-list.txt";
    link.click();
    URL.revokeObjectURL(url);
  };

  // Prevent scroll propagation
  const handleWheel = (event: React.WheelEvent<HTMLDivElement>) => {
    const container = messagesContainerRef.current;
    if (!container) return;

    const { scrollTop, scrollHeight, clientHeight } = container;
    const isAtTop = scrollTop === 0;
    const isAtBottom = scrollTop + clientHeight >= scrollHeight - 1;

    if ((isAtTop && event.deltaY < 0) || (isAtBottom && event.deltaY > 0)) {
      event.preventDefault();
    }
  };

  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    if (!input.trim() || isTyping) return;

    const userInput = input.trim();
    const userMessage: Message = {
      id: `user-${Date.now()}`,
      role: "user",
      content: userInput,
      timestamp: new Date(),
    };

    setMessages((prev) => [...prev, userMessage]);
    setInput("");
    setIsTyping(true);

    // Simulate AI response delay
    setTimeout(
      () => {
        const response = generateResponse(userInput);
        const assistantMessage: Message = {
          id: `assistant-${Date.now()}`,
          role: "assistant",
          content: response.content,
          timestamp: new Date(),
          hasDownload: response.hasDownload,
        };
        setMessages((prev) => [...prev, assistantMessage]);
        setIsTyping(false);
      },
      1000 + Math.random() * 1000,
    );
  };

  const formatTime = (date: Date) => {
    return date.toLocaleTimeString("ja-JP", {
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  return (
    <div className="chatbot-wrapper" ref={wrapperRef}>
      <button
        type="button"
        className={`chatbot-button${isAdmin ? " chatbot-button-admin" : ""}`}
        onClick={handleToggle}
        title="AI アシスタント"
        aria-label="AI アシスタント"
      >
        <svg
          className="chatbot-icon"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M12 2a2 2 0 0 1 2 2c0 .74-.4 1.39-1 1.73V7h1a7 7 0 0 1 7 7h1a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-1v1a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1h1a7 7 0 0 1 7-7h1V5.73c-.6-.34-1-.99-1-1.73a2 2 0 0 1 2-2z" />
          <circle cx="8" cy="14" r="1" fill="currentColor" />
          <circle cx="16" cy="14" r="1" fill="currentColor" />
          <path d="M9 18h6" />
        </svg>
      </button>

      {open && (
        <>
          <div className="chatbot-backdrop" onClick={handleClose} />
          <div className="chatbot-panel" role="dialog" aria-modal="true">
            <div className="chatbot-header">
              <div>
                <p className="chatbot-eyebrow">AI ASSISTANT</p>
                <h3>チャットサポート</h3>
              </div>
              <div className="chatbot-header-actions">
                {isAdmin && (
                  <Link
                    href={`/ai-studio?session=${ADMIN_SESSION_ID}`}
                    className="chatbot-studio-button"
                    title="AI Studio"
                  >
                    <svg
                      width="18"
                      height="18"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    >
                      <rect x="3" y="3" width="18" height="18" rx="2" />
                      <path d="M3 9h18" />
                      <path d="M9 21V9" />
                    </svg>
                  </Link>
                )}
                <button
                  type="button"
                  className="chatbot-close"
                  onClick={handleClose}
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  >
                    <line x1="18" y1="6" x2="6" y2="18" />
                    <line x1="6" y1="6" x2="18" y2="18" />
                  </svg>
                </button>
              </div>
            </div>

            <div
              ref={messagesContainerRef}
              className="chatbot-messages"
              onWheel={handleWheel}
            >
              {messages.map((message) => (
                <div
                  key={message.id}
                  className={`chatbot-message chatbot-message-${message.role}`}
                >
                  <div className="chatbot-message-content">
                    {message.content}
                    {message.hasDownload && (
                      <button
                        type="button"
                        className="chatbot-download-button"
                        onClick={handleDownloadWorksList}
                      >
                        <svg
                          width="14"
                          height="14"
                          viewBox="0 0 24 24"
                          fill="none"
                          stroke="currentColor"
                          strokeWidth="2"
                          strokeLinecap="round"
                          strokeLinejoin="round"
                        >
                          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                          <polyline points="7 10 12 15 17 10" />
                          <line x1="12" y1="15" x2="12" y2="3" />
                        </svg>
                        作品リストをダウンロード
                      </button>
                    )}
                  </div>
                  <div className="chatbot-message-time">
                    {formatTime(message.timestamp)}
                  </div>
                </div>
              ))}
              {isTyping && (
                <div className="chatbot-message chatbot-message-assistant">
                  <div className="chatbot-typing">
                    <span />
                    <span />
                    <span />
                  </div>
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>

            <form className="chatbot-input-form" onSubmit={handleSubmit}>
              <input
                ref={inputRef}
                type="text"
                className="chatbot-input"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                placeholder="メッセージを入力..."
                disabled={isTyping}
              />
              <button
                type="submit"
                className="chatbot-send"
                disabled={!input.trim() || isTyping}
              >
                <svg
                  width="18"
                  height="18"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <line x1="22" y1="2" x2="11" y2="13" />
                  <polygon points="22 2 15 22 11 13 2 9 22 2" />
                </svg>
              </button>
            </form>
          </div>
        </>
      )}
    </div>
  );
}
